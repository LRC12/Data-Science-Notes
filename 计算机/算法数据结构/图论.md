## 图论

### 广度优先搜索

- 求无权图（无向图或有向无环图）的最短路径
- 无向图的强连接元素
- 测试是否是二向图

```python
from collections import defaultdict, deque

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)
    
    def addEdge(self, u, v):
        self.graph[u].append(v)

    def bfs(self, s):
        # For non-weighted graph shortest path(undirected or directed acyclic graph)
        visited = [False for _ in range(len(self.graph))]
        dist = [float('inf') for _ in range(len(self.graph))]
        prev = [-1 for _ in range(len(self.graph))]
        queue = deque()
        visited[s] = True
        dist[s] = 0
        queue.append(s)
        while queue:
            u = queue.popleft()
            for v in self.graph[u]:
                if not visited[v]:
                    visited[v] = True
                    dist[v] = dist[u] + 1
                    prev[v] = u
                    queue.append(v)
    
    def scc(self):
        # Strongly connected component of an undirected graph
        visited = [False for _ in range(len(self.graph))]
        res = []
        for s in range(len(visited)):
            if not visited[s]:
                temp = []
                queue = deque()
                visited[s] = True
                queue.append(s)
                while queue:
                    u = queue.popleft()
                    for v in self.graph[u]:
                        if not visited[v]:
                            visited[v] = True
                            queue.append(v)
                            temp.append(v)
                res.append(temp)
    
    def testBipartite(self, s):
        # Test bipartiteness of an undirected graph
        color = [-1 for _ in range(len(self.graph))]
        queue = deque()
        color[s] = 0
        queue.append(s)
        while queue:
            u = queue.popleft()
            for v in self.graph[u]:
                if color[v] == -1:
                    color[v] = 1 - color[u]
                    queue.append(v)
                elif color[v] == color[u]:
                    return False
        return True
```

### 深度优先搜索

- DFS输出遍历节点的起始与终止时间，判断forward edge, back edge, cross edge
- DFS测试有向图是否有环
- 输出拓扑排序顺序
- 找到全连接元素

```python
from collections import defaultdict, deque

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)
    
    def addEdge(self, u, v):
        self.graph[u].append(v)

    def dfs(self, s):
        # Output the start time and end time of visiting a vertex
        visited = [False for _ in range(len(self.graph))]
        start = [0 for _ in range(len(self.graph))]
        finish = [0 for _ in range(len(self.graph))]
        time = 0
        def search(u):
            time += 1
            start[u] = time
            visited[u] = True
            for v in self.graph[u]:
                if not visited[v]:
                    search[v]
            time += 1
            finish[u] = time
        search(s) 

    def testCycle(self, s, visited, backpath):
        # Test if there is back edge in a DFS tree
        # O(n+m) time complexity
        if visited[s]:
            return False
        if backpath[s]:
            return True
        backpath[s] = True
        for v in graph[s]:
            if self.testCycle(v, graph, visited, backpath):
                return True
        backpath[s] = False
        visited[s] = True
        return False
    
    def topoOrder(self):
        # Time complexity O(n+m)
        from collections import defaultdict, deque
        queue = deque()
        indegree = defaultdict(int)
        topo_order = []
        for k, v in self.graph.items():
            for vertex in v:
                indegree[vertex] += 1
        for node, value in indegree.items():
            if value == 0:
                queue.append(node)
        while queue:	
            u = queue.popleft()
            for v in self.graph[u]:
                indegree[v] -= 1
                removed_edges += 1
                if indegree[v] == 0:
                    queue.append(v)
                    topo_order.append(v)
        return topo_order
      
    def scc(self):
        self.graphr = defaultdict(list)
        for k, v in self.graph.items():
            for item in v:
                self.graphr[item].append(k)

        topoorder = self.topoOrder(self.graphr)
        scc = []
        for v in topoorder:
            scc.append(self.dfs(v))
        return scc
```

### 最短路径

- Dijkstra 算法

```python
class Graph:
    def __init__(self, n, m):
        self.graph = [-1 for _ in range(n) for _ in range(n)]
    
    def addEdge(self, u, v, w):
        self.graph[u][v] = w

    def dijkstra(self, s):
        dist = [float('inf') for _ in range(len(self.graph))]
        dist[s] = 0
        S = set()
        
        while len(S) < len(dist):
            minimum = float('inf')
            index = -1
            for i, item in enumerate(dist):
                if i not in S and item < minimum:
                    minimum = item
                    index = i
            S.add(i)
            for v in range(len(self.graph)):
                if graph[i][v] >= 0 and dist[v] > dist[i] + self.graph[i][v]:
                    dist[v] = dist[i] + self.graph[i][v]
        return dist
```

