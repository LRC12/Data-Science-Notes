## 广度优先搜索

- 求无权图（无向图或有向无环图）的最短路径
- 无向图的强连接元素
- 测试是否是二向图

```python
from collections import defaultdict, deque

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)
    
    def addEdge(self, u, v):
        self.graph[u].append(v)

    def bfs(self, s):
        # For non-weighted graph shortest path(undirected or directed acyclic graph)
        visited = [False for _ in range(len(self.graph))]
        dist = [float('inf') for _ in range(len(self.graph))]
        prev = [-1 for _ in range(len(self.graph))]
        queue = deque()
        visited[s] = True
        dist[s] = 0
        queue.append(s)
        while queue:
            u = queue.popleft()
            for v in self.graph[u]:
                if not visited[v]:
                    visited[v] = True
                    dist[v] = dist[u] + 1
                    prev[v] = u
                    queue.append(v)
    
    def scc(self):
        # Strongly connected component of an undirected graph
        visited = [False for _ in range(len(self.graph))]
        res = []
        for s in range(len(visited)):
            if not visited[s]:
                temp = []
                queue = deque()
                visited[s] = True
                queue.append(s)
                while queue:
                    u = queue.popleft()
                    for v in self.graph[u]:
                        if not visited[v]:
                            visited[v] = True
                            queue.append(v)
                            temp.append(v)
                res.append(temp)
    
    def testBipartite(self, s):
        # Test bipartiteness of an undirected graph
        color = [-1 for _ in range(len(self.graph))]
        queue = deque()
        color[s] = 0
        queue.append(s)
        while queue:
            u = queue.popleft()
            for v in self.graph[u]:
                if color[v] == -1:
                    color[v] = 1 - color[u]
                    queue.append(v)
                elif color[v] == color[u]:
                    return False
        return True
```

## 深度优先搜索

- DFS输出遍历节点的起始与终止时间，判断forward edge, back edge, cross edge
- DFS测试有向图是否有环
- 输出拓扑排序顺序
- 找到全连接元素

```python
from collections import defaultdict, deque

class Graph:
    def __init__(self):
        self.graph = defaultdict(list)
    
    def addEdge(self, u, v):
        self.graph[u].append(v)

    def dfs(self, s):
        # Output the start time and end time of visiting a vertex
        visited = [False for _ in range(len(self.graph))]
        start = [0 for _ in range(len(self.graph))]
        finish = [0 for _ in range(len(self.graph))]
        time = 0
        def search(u):
            time += 1
            start[u] = time
            visited[u] = True
            for v in self.graph[u]:
                if not visited[v]:
                    search[v]
            time += 1
            finish[u] = time
        search(s) 

    def testCycle(self, s, visited, backpath):
        # Test if there is back edge in a DFS tree
        # O(n+m) time complexity
        if visited[s]:
            return False
        if backpath[s]:
            return True
        backpath[s] = True
        for v in graph[s]:
            if self.testCycle(v, graph, visited, backpath):
                return True
        backpath[s] = False
        visited[s] = True
        return False
    
    def topoOrder(self):
        # Time complexity O(n+m)
        from collections import defaultdict, deque
        queue = deque()
        indegree = defaultdict(int)
        topo_order = []
        for k, v in self.graph.items():
            for vertex in v:
                indegree[vertex] += 1
        for node, value in indegree.items():
            if value == 0:
                queue.append(node)
        while queue:	
            u = queue.popleft()
            for v in self.graph[u]:
                indegree[v] -= 1
                removed_edges += 1
                if indegree[v] == 0:
                    queue.append(v)
                    topo_order.append(v)
        return topo_order
      
    def scc(self):
        self.graphr = defaultdict(list)
        for k, v in self.graph.items():
            for item in v:
                self.graphr[item].append(k)

        topoorder = self.topoOrder(self.graphr)
        scc = []
        for v in topoorder:
            scc.append(self.dfs(v))
        return scc
```

## 最短路径

- Dijkstra 算法：无负向边的带权有向无环图最短路径算法，时间复杂度O(mlogn)

```python
def dijkstra(self, s, graph):
    dist = [float('inf') for _ in range(len(self.graph))]
    dist[s] = 0
    S = set()

    while len(S) < len(dist):
        minimum = float('inf')
        index = -1
        for i, item in enumerate(dist):
            if i not in S and item < minimum:
            minimum = item
            index = i
            S.add(i)
            for v in range(len(self.graph)):
                if graph[i][v] >= 0 and dist[v] > dist[i] + self.graph[i][v]:
                dist[v] = dist[i] + self.graph[i][v]
                return dist
```

- Bellman-ford算法：可以处理含负向边的最短路径问题，同时判断图中是否有负向环，时间复杂度O(nm)

最优子问题：最多经过i条边从s到达v，$OPT(i, v)$

状态转移方程：$OPT(i, v) = min(OPT(i-1, v), min(OPT_{(x,v)\in E}(i-1, x) + w(x, v)))$

边界条件：$OPT(0, s)=0, OPT(0, v)=\inf$

```python
def bellmanford(self, s, graph):
    n = len(graph)
    dp = [[0 for _ in range(n)] for _ in range(n)]
    for i in range(n):
    if i == s:
            dp[0][i] = 0
        else:
            dp[0][i] = float('inf')
        for i in range(1, n):
            for j in range(n):
                for k in graph[j].keys()
                    dp[i][j] = min(dp[i-1][j], dp[i-1][k]+graph[j][k])
        return dp
```

判断负向环：s-v路径最多包含n-1条边，执行n次更新操作，若第n次有s-v距离改变，则包含负向边

## 网络流

### 网络流条件

- Capacity constraints: for all $e\in E$, $0\le f(e)\le c_e$
- Flow conservation: for all $v\in V-{s, t}$, $\sum f(u,v)=\sum f(v, w)$

### 网络流求解

通过残差图和增广路径求解，Ford-Fulkerson algorithm

forward edge: edges with leftover capacity

backward edge: edges that are already carrying flow so as to divert it to a different direction

Augment path: P is a simple s-t path in $G_f$, push at most $min c_f(e)$ capacity, which is the minimum residual capacity in the s-t path

- For a forward edge, $f'(e)=f(e)+c(P)$
- for a backward edge, $f'(e)=f(e)-c(P)$

最大流与最小割强对偶：in every flow network, the maximum value of an s-t flow equals the minimum capacity of an s-t cut
